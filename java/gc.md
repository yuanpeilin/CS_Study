# 引用
###### 强引用
* 例如: `Object obj =new Object();` Object这类对象就具有强引用, 属于不可回收的资源, 垃圾回收器绝不会回收它
* 当内存空间不足, Java虚拟机宁愿抛出OutOfMemoryError错误, 使程序异常终止, 也不会靠回收具有强引用的对象, 来解决内存不足的问题  

###### 软引用(SoftReference)
* 如果一个对象只具有软引用, 那么它的性质属于可有可无的那种. 
* 如果此时内存空间足够, 垃圾回收器就不会回收它, 如果内存空间不足了, 就会回收这些对象的内存. 只要垃圾回收器没有回收它, 该对象就可以被程序使用

###### 弱引用(WeakReference)
* 如果一个对象具有弱引用, 那其的性质也是可有可无的状态. 
* 而弱引用和软引用的区别在于: 弱引用的对象拥有更短的生命周期, 只要垃圾回收器扫描到它, 不管内存空间充足与否, 都会回收它的内存
* 弱引用的生命周期要比软引用短很多. 不过, 如果垃圾回收器是一个优先级很低的线程, 也不一定会很快就会释放掉软引用的内存

###### 虚引用(PhantomReference)
* 虚引用和前面的软引用、弱引用不同, 它并不影响对象的生命周期. 如果一个对象与虚引用关联, 则跟没有引用与之关联一样, 在任何时候都可能被垃圾回收器回收. 


# Java对象的访问方式
###### 通过句柄访问
* 通过句柄访问的实现方式中, JVM堆中会专门有一块区域用来作为句柄池, 存储相关句柄所执行的实例数据地址(包括在堆中地址和在方法区中的地址). 
* 这种实现方法由于用句柄表示地址, 因此十分稳定

###### 通过直接指针访问
* 通过直接指针访问的方式中, reference中存储的就是对象在堆中的实际地址, 在堆中存储的对象信息中包含了在方法区中的相应类型数据. 
* 这种方法最大的优势是速度快, 在HotSpot虚拟机中用的就是这种方式


# 总体思路
Java内存分配和回收的机制概括的说, 就是: **分代分配, 分代回收** . 对象将根据存活的时间被分为: 年轻代(Young Generation)、年老代(Old Generation)、永久代(Permanent Generation, 也就是方法区)


# 如何找垃圾
###### 引用计数法
* 给对象中添加一个引用计数器, 每当一个地方引用这个对象时, 计数器值+1
* 当引用失效时, 计数器值-1
* 任何时刻计数值为0的对象就是不可能再被使用的
* 这种算法很难解决对象之间相互引用的情况

###### 可达性分析
* 把所有引用的对象想象成一棵树, 从树的根结点 **GC Roots** 出发, 持续遍历找出所有连接的树枝对象, 这些对象则被称为"存活"对象. 其余的对象则被视为"死亡"的"不可达"对象, 或称"垃圾". 
* Java 里有哪些对象是一定可达呢？
    - 虚拟机栈(帧栈中的本地变量表)中引用的对象
    - 方法区静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中 JNI 引用的对象


# 如何回收垃圾
###### 标记-清除(Mark-Sweep)算法
* 分为"标记"和"清除"两个阶段: 首先标记出所有需要回收的对象, 标记完成后统一回收所有被标记的对象
* 不足主要体现在效率和空间, 从效率的角度讲, 标记和清除两个过程的效率都不高；从空间的角度讲, 标记清除后会产生大量不连续的内存碎片

###### 复制(Copying)算法
* 复制算法是为了解决效率问题而出现的, 每次进行清理时, 将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中, 然后清理掉Eden和刚才的Survivor
* Eden区与Survivor的比例较大, HotSpot默认是 8:1, 即分别占新生代的80%, 10%, 10%. 如果一次回收中, Survivor+Eden中存活下来的内存超过了10%, 则需要将一部分对象分配到老年代

###### Mark-Compact(标记-整理)算法
* 为了解决Copying算法的缺陷, 充分利用内存空间, 提出了Mark-Compact算法
* 该算法标记阶段和Mark-Sweep一样, 但是在完成标记之后, 它不是直接清理可回收对象, 而是将存活对象都向一端移动, 然后清理掉端边界以外的内存


# GC机制的基本算法是: 分代收集
###### 年轻代(Young Generation): Young GC / Minor GC
* 对象被创建时, 内存的分配首先发生在年轻代, 大部分的对象在创建后很快就不再使用, 因此很快变得不可达, 于是被年轻代的GC机制清理掉, 这个GC机制被称为Young GC, 也叫Minor GC
* 年轻代可以分为3个区域: Eden区和两个存活区(Survivor 0 、Survivor 1). Eden区是连续的内存空间, 因此在其上分配内存极快. 经过一次GC和复制, 一个Survivor中保存着当前还活着的对象, 而Eden区和另一个Survivor区的内容都不再需要了, 可以直接清空, 到下一次GC时, 两个Survivor的角色再互换
* 这种垃圾回收的方式就是著名的 **停止-复制(Stop-and-copy)** 清理法

###### 年老代(Old Generation): Major GC / Full GC
* 对象如果在年轻代存活了足够长的时间而没有被清理掉(即在几次Young GC后存活了下来), 则会被复制到年老代, 年老代的空间一般比年轻代大, 能存放更多的对象, 在年老代上发生的GC次数也比年轻代少. 当年老代内存不足时, 将执行Major GC, 也叫 Full GC
* 老年代用的算法是 **标记-整理算法** , 即: 标记出仍然存活的对象(存在引用的), 将所有存活的对象向一端移动, 以保证内存的连续

###### 方法区(永久代): 
* 永久代的回收有两种: 常量池中的常量, 无用的类信息, 常量的回收很简单, 没有引用了就可以被回收. 对于无用的类进行回收, 必须保证3点: 
    * 类的所有实例都已经被回收
    * 加载类的ClassLoader已经被回收
    * 类对象的Class对象没有被引用(即没有通过反射引用该类的地方)
* 永久代的回收并不是必须的, 可以通过参数来设置是否对类进行回收


# 收集器类型
###### Serial收集器: 新生代收集器 复制算法 单线程
* 使用一个线程进行GC, 串行, 其它工作线程暂停

###### Parallel收集器: 新生代收集器 复制算法 多线程
* Serial收集器的多线程版, 用多个线程进行GC, 并行, 其它工作线程暂停, 关注缩短垃圾收集时间

###### Parallel Scavenge 收集器: 新生代收集器 复制算法
* 关注CPU吞吐量, 即运行用户代码的时间/总时间, 比如: JVM运行100分钟, 其中运行用户代码99分钟, 垃 圾收集1分钟, 则吞吐量是99%, 这种收集器能最高效率的利用CPU, 适合运行后台运算

###### Serial Old收集器: 老年代收集器 标记整理 单线程
* 串行, 使用标记整理(整理的方法是Sweep(清理)和Compact(压缩), 清理是将废弃的对象干掉, 只留幸存的对象, 压缩是将移动对象, 将空间填满保证内存分为2块, 一块全是对象, 一块空闲)算法, 使用单线程进行GC, 其它工作线程暂停(注意, 在老年代中进行标记整理算法清理, 也需要暂停其它线程), 在JDK1.5之前, Serial Old收集器与ParallelScavenge搭配使用

###### Parallel Old收集器: 老年代收集器 多线程
* 并行, 多线程机制与Parallel Scavenge差不错, 使用标记整理(与Serial Old不同, 这里的整理是Summary(汇总)和Compact(压缩), 汇总的意思就是将幸存的对象复制到预先准备好的区域, 而不是像Sweep(清理)那样清理废弃的对象)算法, 在Parallel Old执行时, 仍然需要暂停其它线程. Parallel Old在多核计算中很有用

###### CMS(Concurrent Mark Sweep)收集器: 老年代收集器 多线程
* 致力于获取最短回收停顿时间(即缩短垃圾回收的时间), 使用标记清除算法, 优点是并发收集(用户线程可以和GC线程同时工作), 停顿小


# 并发并行
* 并发是指用户线程与GC线程同时执行(不一定是并行, 可能交替, 但总体上是在同时执行的), 不需要停顿用户线程(其实在CMS中用户线程还是需要停顿的, 只是非常短, GC线程在另一个CPU上执行)
* 并行收集是指多个GC线程并行工作, 但此时用户线程是暂停的
* 所以, Serial是串行的, Parallel收集器是并行的, 而CMS收集器是并发的
