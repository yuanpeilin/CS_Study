# 日期
下面是正确的格式化输出日期的方式, 各个字母的含义为:
* `yyyy` 年份, 只能使用这个
* `YYYY` 年份, 使用这个会有bug
* `mm` 分钟数
* `MM` 月份数
* `dd` 每个月的几号
* `DD` 当前距离每年第一天的天数
* `ss` 秒数

```java
Date date = new Date();
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
System.out.println(simpleDateFormat.format(date));

// 2020-01-13 13:28:09
```
* `Date`和`SimpleDateFormat`是线程不安全的

# euqals ==
* **equals** 
    * 默认情况下，比较的是地址. 需要自己重写`equals()`
    * equals方法比较的是两个对象的内容是否相同，因此，对象必须有指向的空间，即不能为null，否则，会抛出异常
* **==**
    * 对于**基本数据类型**, 比较的是他们的值. 对于**引用数据类型**, 比较的是他们内存中的地址

# 访问修饰符

symbol    | 同类  | 同包 | 子类 | 外部包
:--       | :--   | :--  | :--  | :-- 
public    | √     | √    | √    | √ 
protected | √     | √    | √    | × 
default   | √     | √    | ×    | × 
private   | √     | ×    | ×    | × 

# 封装集成多态
#### 封装
封装可以被认为是一个保护屏障, 防止该类的代码和数据被外部类定义的代码随机访问. 封装最主要的功能在于我们能修改自己的实现代码, 而不用修改那些调用我们代码的程序片段
1. 良好的封装能够减少耦合
2. 类内部的结构可以自由修改
3. 可以对成员变量进行更精确的控制
4. 隐藏信息, 实现细节

#### 继承

#### 多态
当使用多态方式调用方法时, 首先检查父类中是否有该方法, 如果没有, 则编译错误；如果有, 再去调用子类的同名方法

# 接口和抽象类
#### 抽象类
* 因为抽象类中含有无具体实现的方法, 所以不能用抽象类创建对象
* 对于一个父类, 如果它的某个方法在父类中实现出来没有任何意义, 必须根据子类的实际需求来进行不同的实现, 那么就可以将这个方法声明为abstract方法, 此时这个类也就成为abstract类了
* 如果一个类继承于一个抽象类, 则子类必须实现父类的抽象方法. 如果子类没有实现父类的抽象方法, 则必须将子类也定义为为abstract类
* 抽象方法必须为public或者protected(因为如果为private, 则不能被子类继承, 子类便无法实现该方法), 缺省情况下默认为public

#### 接口
* 变量会被隐式地指定为**`public static final 变量`**
* 方法会被隐式地指定为**`public abstract 方法`**

#### 区别
* 抽象类可以提供**方法**的实现细节, 而接口中只能存在`public abstract 方法`
* 抽象类中的**变量**可以是各种类型的, 而接口中的变量只能是`public static final 变量`
* 抽象类可以有**静态代码块和静态方法**, 而接口中不能含有静态代码块以及静态方法
* 一个类只能继承一个抽象类, 而一个类却可以实现多个接口  

抽象类是对 **整个类** 整体进行抽象, 包括属性、行为, 但是接口却是对类 **局部** (行为)进行抽象. 举个简单的例子, 飞机和鸟是不同类的事物, 但是它们都有一个共性, 就是都会飞. 那么在设计的时候, 可以将飞机设计为一个类Airplane, 将鸟设计为一个类Bird, 但是不能将 飞行 这个特性也设计为类, 因此它只是一个行为特性, 并不是对一类事物的抽象描述. 此时可以将 飞行 设计为一个接口Fly, 包含方法fly(), 然后Airplane和Bird分别根据自己的需要实现Fly这个接口  
然后至于有不同种类的飞机, 比如战斗机、民用飞机等直接继承Airplane即可, 对于鸟也是类似的, 不同种类的鸟直接继承Bird类即可. 从这里可以看出, 继承是一个 "是不是"的关系, 而 接口 实现则是 "有没有"的关系. 如果一个类继承了某个抽象类, 则子类必定是抽象类的种类, 而接口实现则是有没有、具备不具备的关系, 比如鸟是否能飞(或者是否具备飞行这个特点), 能飞行则可以实现这个接口, 不能飞行就不实现这个接口

# 重写与重载
###### 重写
* 子类重写方法的访问修饰符范围可以不变，也可以变大
* 重写方法的方法名、返回值类型、参数名和参数类型必须和父类中的一致
* 当子类调用方法时，子类父类中都有此方法(也就是子类重写了此方法)，则优先调用子类中的方法，如果没有当然调用父类中的方法

###### 重载
* 重载的方法必须和以前方法的方法名一致
* 重载方法的返回值类型和以前方法的类型可以一样，可以不一样，不能以此作为重载的依据
* 重载方法的参数类型、参数顺序或参数个数必须和以前方法的不一致



