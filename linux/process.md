# 目录
- [系统引导流程](#系统引导流程)
- [BIOS自检](#bios自检)
- [MBR](#mbr)
- [init进程](#init进程)
- [/etc/inittab](#etcinittab)
- [运行级别](#运行级别)
    - [id](#id)
    - [runlevels](#runlevels)
    - [action](#action)
    - [process](#process)
- [父子进程](#父子进程)



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# 系统引导流程
1. 开机BIOS自检, 加载硬盘
2. 读取MBR,进行MBR引导
3. grub引导菜单(Boot Loader)
4. 加载内核kernel
5. 启动init进程, 依据 **/etc/inittab**文件设定运行级别
6. init进程, 执行 **/etc/rc.d/rc.sysinit**文件
7. 启动内核模块, 执行不同级别的脚本程序
8. 执行 **/etc/rc.d/rc.local**
9. 启动 **mingetty**, 进入系统登陆界面
![](src/init.png)



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# BIOS自检
* 步骤1: 上电自检POST(Power-on self test), 主要负责检测系统外围关键设备(如: CPU、内存、显卡、I/O、键盘鼠标等)是否正常. 例如, 最常见的是内存松动的情况, BIOS自检阶段会报错, 系统就无法启动起来；
* 步骤2: 步骤1成功后, 便会执行一段小程序用来枚举本地设备并对其初始化. 这一步主要是根据我们在BIOS中设置的系统启动顺序来搜索用于启动系统的驱动器, 如硬盘、光盘、U盘、软盘和网络等. 



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# MBR
主引导记录(Master Boot Record). 对于Linux, 位于MBR里的通常会是GRUB加载器. GRUB作用: 
1. 选择操作系统(如果计算机上安装了多个操作系统)
2. 表示相应引导文件所在的分区
3. 找到内核
4. 运行初始内存盘, 设置内核与相关模块



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# init进程
* /sbin/init进程是所有进程的起点, 内核在完成内核引导后, 即在本线程(进程)空间内加载init程序, 它的 **进程号为1**
* init进程是所有进程的发起者和控制者
* init进程有两个作用:
    * 扮演终结父进程的角色: 所有的孤儿进程都会被init进程接管
    * 进入某个特定的运行级别时运行相应的程序, 以此对各种运行级别进行管理, 这个作用由/etc/inittab文件定义的



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# /etc/inittab
* /sbin/init进程是系统其他所有进程的父进程, 当它接管了系统的控制权先之后, 它首先会去读取/etc/inittab文件来执行相应的脚本进行系统初始化, 如设置键盘、字体, 装载模块, 设置网络等. 主要包括以下工作: 
    * 执行系统初始化脚本 **/etc/rc.d/rc.sysinit**, 对系统进行基本的配置, 以读写方式挂载根文件系统及其它文件系统, 到此系统算是基本运行起来了, 后面需要进行运行级别的确定及相应服务的启动. 
    * 执行 **/etc/rc.d/rc**脚本. 根据指定的运行级别, 加载或终止相应的系统服务. 具体的每个运行级别的服务状态是放在/etc/rc.d/rc\*.d(\*=0\~6)目录
    * 执行用户自定义引导程序 **/etc/rc.d/rc.local**. 这个shell脚本就是保留给用户自定义启动内容的



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# 运行级别
* **7种运行级别**
    * 0: 关机状态
    * 1: 单用户模式
    * 2: 字符界面的多用户模式(不支持网络)
    * 3: 字符界面的完整多用户模式
    * 4: 未分配使用
    * 5: 图形界面的多用户模式
    * 6: 重新启动
* **修改默认运行级别:** 修改 /etc/inittab 文件中的 initdefault 配置行
```sh
$ sudo vim /etc/inittab 
id:3:initdefault:
```
* inittab文件的结构
```sh
x  : 5         : respawn : /etc/X11/prefdm -nodaemon 
id : runlevels : action  : process
```

## id
> 也称标记字段, 由1\~4个字符组成, 用以区别于其他行的配置, 所以id标记字段必须是唯一的, 用于在inittab文件中唯一标识一个配置记录
## runlevels
> 运行级别字段, 用于指定该记录在哪些运行级别中运行, 取值数字0\~6
## action
> 动作类型字段, 动作类型字段描述了该行配置所对应的操作类别, 一般为固定值, 较常用的类型如下: 

字段 | 说明
:-- | :--
**initdefault** | 设置初始化系统后默认进入的运行级别
**sysinit** | 设置系统初始化的操作脚本
**wait** | init进程将等待该行配置所对应的脚本操作完成后, 再继续执行其他操作
**ctrlaltdel** | 设置当用户按下Ctrl+Alt+Delete组合键后的操作
**powerfail** | 设置当系统收到断电信号(使用不间断电源)时采取何种动作
**powerokwait** | 设置当系统收到恢复供电信号时采取何种动作
**respawn** | 一旦该行配置所对应的进程被终止, 则重新启动该进程. 比如用户可以登陆退出, 再登陆再退出
## process
> 用于指定该行配置所对应的实际操作, 可以是具体的命令、脚本程序等

```sh
例如random.init包含三行:
# chkconfig: 2345 20 80
# description: Saves and restores system entropy pool for \
# higher quality random number generation.
```
* 每个被chkconfig管理的服务需要在对应的init.d下的脚本加上两行或者更多行的注释
    * 第一行告诉chkconfig缺省启动的运行级以及启动和停止的优先级. 如果某服务缺省不在任何运行级启动, 那么使用-代替运行级
    * 第二行对服务进行描述, 可以用\跨行注释



<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->
<!-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -->



# 父子进程
1. 子进程是由一个进程所产生的进程，产生这个子进程的进程称为父进程
2. 在linux系统中，使用系统调用fork创建进程。fork复制的内容包括父进程的数据和堆栈段以及父进程的进程环境
3. 父进程终止子进程自然终止
